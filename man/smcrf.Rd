% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smcrf.r
\name{smcrf}
\alias{smcrf}
\title{Approximate Bayesian Computation sequential Monte Carlo via random forests}
\usage{
smcrf(
  method = "smcrf-single-param",
  statistics_target = NULL,
  statistics_selection = NULL,
  smcrf_results = NULL,
  model,
  perturb,
  bounds = NULL,
  parameters_initial = NULL,
  nParticles,
  parallel = FALSE,
  save_model = TRUE,
  save_rds = FALSE,
  filename_rds = "ABCSMCDRF.rds",
  ...
)
}
\arguments{
\item{method}{Random forest method to implement in each iteration ("smcrf-single-param" by default).
method = "smcrf-single-param": implements ABC-RF for each parameter and results in their marginal posterior distributions.
method = "smcrf-multi-param": implements ABC-DRF for all parameters and results in the joint posterior distribution.}

\item{statistics_target}{A dataframe containing statistics from data.
Column names are the statistics IDs.
\code{\link{smcrf}} only supports one row of statistics.
If there are multiple observations, we recommend applying \code{\link{smcrf}} to each row individually.}

\item{statistics_selection}{A dataframe indicating selection of statistics for fitting individual parameters (only works for method "smcrf-single-param"; NULL by default).
Each column's name is one statistic ID, and each row's name is one parameter ID.
The value is 1 if the statistic is used for the parameter, 0 otherwise.}

\item{smcrf_results}{An existing ABC-SMC-RF result.
If provided, smcrf will continue ABC-SMC-RF from the last iteration of the previous run.}

\item{model}{Model for the statistics.
The function must take two inputs: a data frame parameters and logic variable parallel.
The model will output a reference table.
Each row contains parameters for each simulation and corresponding statistics.}

\item{perturb}{A choice of kernel function that perturbs parameters for ABC-SMC-RF in each iteration.
If perturb is a specified perturbation kernel function, each parameter follows the perturb function.}

\item{bounds}{A dataframe containing bounds for each parameter.
Usually no larger than the bounds of prior distribution.}

\item{parameters_initial}{A dataframe containing the initial guess for parameters.
Each column represents the prior distribution for corresponding parameter.}

\item{nParticles}{A list of numbers showing the particles of ABC-SMC-RF.
Each entry indicates the number of simulations in the corresponding iteration.}

\item{parallel}{A logic variable (parallel = FALSE by default).
If parallel = TRUE, the ABC-RF functions will be computed in parallel.}

\item{save_model}{A logic variable (parallel = FALSE by default).
If save_model = TRUE, the random forest will be saved in the output.}

\item{save_rds}{A logic variable (parallel = FALSE by default).
If save_rds = TRUE, the ABC-SMC-RF results will be saved in an rds file.}

\item{filename_rds}{A string (filename_rds = "ABCSMCDRF.rds" by default).
If save_rds = TRUE, the output from ABC-SMC-(D)RF will be saved in a file with this name.}

\item{...}{Additional arguments to be passed to \code{abcrf} or \code{drf}.}
}
\value{
An object \code{smcrf_results} containing the results of the inference.
If the posterior distributions have not converged to a satisfactory level,
the user may continue with \code{smcrf(smcrf_results = smcrf_results, ...)},
in which case ABC-SMC-(D)RF will continue iterating from the last run in \code{smcrf_results}.
}
\description{
\code{\link{smcrf}} uses random forests to find the posterior distribution(s) for one or more parameters in a model.
It implements the sequential Monte Carlo framework, where each iteration
uses either ABC-RF (functions \code{regAbcrf} and \code{predict} in R package \code{abcrf})
or ABC-DRF (functions \code{drf} and \code{predict} in R package \code{drf}) to update the posterior distribution(s).
}
\examples{
library(abcsmcrf)
#--------------------------------------------------------------------
#---------------------------ABC-SMC-RF for a model with one parameter
#--------------------------------------------------------------------
# Data to be fitted consists of two statistics s1 and s2
statistics_target <- data.frame(s1 = 0, s2 = 2)
# We then define a parametrized model for the statistics
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$theta - 1 + runif(nrow(parameters), -0.1, 0.1),
        s2 = parameters$theta + 1 + runif(nrow(parameters), -0.1, 0.1)
    )
    cbind(parameters, statistics)
}
# and a function to perturb the parameters with random noise between iterations
perturb <- function(parameters) {
    parameters$theta <- parameters$theta + runif(nrow(parameters), min = -0.1, max = 0.1)
    return(parameters)
}
# We start from initial guesses for theta from Uniform(-10, 10)
parameters_initial <- data.frame(theta = runif(100000, -10, 10))
# while ensuring that theta stays within bounds
bounds <- data.frame(
    parameter = c("theta"),
    min = c(-10),
    max = c(10)
)
# Finally, we run ABC-SMC-RF with 2 iterations, each with 1000 particles
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    statistics_target = statistics_target,
    model = model,
    perturb = perturb,
    bounds = bounds,
    parameters_initial = parameters_initial,
    nParticles = c(1000, 1000),
)
# Now we examine the posterior distribution of theta
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_theta <- smcrf_results[[posterior_iteration]]$parameters$theta
# We look at the posterior mean of theta
theta_mean <- mean(posterior_theta)
print(theta_mean)
# Notice that the mean is close to 1, the true value of theta.
# We can also look at the posterior variance of theta
theta_var <- var(posterior_theta)
print(theta_var)
# We can also continue the ABC-SMC-RF run if the posterior convergence is not satisfactory
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    smcrf_results = smcrf_results,
    model = model,
    perturb = perturb,
    bounds = bounds,
    nParticles = c(1000, 1000)
)
# We look again at the posterior mean and variance of theta
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_theta <- smcrf_results[[posterior_iteration]]$parameters$theta
theta_mean <- mean(posterior_theta)
print(theta_mean)
theta_var <- var(posterior_theta)
print(theta_var)
# and notice whether there is any improvement in the posterior distribution
# We can continue the runs of ABC-SMC-(D)RF similarly for the examples below
#--------------------------------------------------------------------
#---------------------ABC-SMC-RF for a model with multiple parameters
#--------------------------------------------------------------------
# Data to be fitted consists of two statistics s1 and s2
statistics_target <- data.frame(s1 = 4, s2 = 4)
# We then define a parametrized model for the statistics
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$mu + parameters$theta + runif(nrow(parameters), -0.1, 0.1),
        s2 = parameters$mu * parameters$theta + runif(nrow(parameters), -0.1, 0.1)
    )
    cbind(parameters, statistics)
}
# and a function to perturb the parameters with random noise between iterations
perturb <- function(parameters) {
    if (any(grepl("theta", colnames(parameters)))) {
        parameters[["theta"]] <- parameters[["theta"]] + runif(nrow(parameters), min = -0.1, max = 0.1)
    } else if (any(grepl("mu", colnames(parameters)))) {
        parameters[["mu"]] <- parameters[["mu"]] + runif(nrow(parameters), min = -0.1, max = 0.1)
    }
    return(parameters)
}
# We start from initial guesses from U(-10, 10) x U(-10, 10)
parameters_initial <- data.frame(
    theta = runif(100000, -10, 10),
    mu = runif(100000, -10, 10)
)
# while ensuring that the parameters stay within bounds
bounds <- data.frame(
    parameter = c("theta", "mu"),
    min = c(-10, -10),
    max = c(10, 10)
)
# Finally, we run ABC-SMC-RF with 3 iterations, each with 1000 particles
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    statistics_target = statistics_target,
    model = model,
    perturb = perturb,
    bounds = bounds,
    parameters_initial = parameters_initial,
    nParticles = c(1000, 1000, 1000),
)
# Now we examine the posterior distribution of each parameter
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_params <- smcrf_results[[posterior_iteration]]$parameters
posterior_means <- colMeans(posterior_params)
posterior_vars <- var(posterior_params)
print(posterior_means)
print(posterior_vars)
#--------------------------------------------------------------------
#--------------------------------ABC-SMC-DRF for a multivariate model
#--------------------------------------------------------------------
# Data to be fitted consists of 3 statistics s1, s2 and s3
statistics_target <- data.frame(s1 = 9, s2 = 18)
# We then define a parametrized model for the statistics
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$mu + parameters$theta + runif(nrow(parameters), -0.1, 0.1),
        s2 = parameters$mu * parameters$theta + runif(nrow(parameters), -0.1, 0.1)
    )
    cbind(parameters, statistics)
}
# and a function to perturb the parameters with random noise between iterations
perturb <- function(parameters) {
    if (any(grepl("theta", colnames(parameters)))) {
        parameters[["theta"]] <- parameters[["theta"]] + runif(nrow(parameters), min = -0.1, max = 0.1)
    } else if (any(grepl("mu", colnames(parameters)))) {
        parameters[["mu"]] <- parameters[["mu"]] + runif(nrow(parameters), min = -0.1, max = 0.1)
    }
    return(parameters)
}
# We start from initial guesses from U(-10, 10) x U(-10, 10)
theta <- runif(100000, -10, 10)
parameters_initial <- data.frame(
    theta = runif(100000, -10, 10),
    mu = runif(100000, -10, 10)
)
# while ensuring that the parameters stay within bounds
bounds <- data.frame(
    parameter = c("theta", "mu"),
    min = c(-10, -10),
    max = c(10, 10)
)
# Finally, we run ABC-SMC-DRF with 3 iterations, each with 1000 particles
smcrf_results <- smcrf(
    method = "smcrf-multi-param",
    statistics_target = statistics_target,
    model = model,
    perturb = perturb,
    bounds = bounds,
    parameters_initial = parameters_initial,
    nParticles = c(1000, 1000, 1000),
)
# Now we examine the posterior distribution of each parameter
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_params <- smcrf_results[[posterior_iteration]]$parameters
posterior_means <- colMeans(posterior_params)
posterior_vars <- var(posterior_params)
print(posterior_means)
print(posterior_vars)
}
