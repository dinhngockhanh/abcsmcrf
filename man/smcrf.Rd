% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smcrf.r
\name{smcrf}
\alias{smcrf}
\title{Approximate Bayesian Computation sequential Monte Carlo via random forests}
\usage{
smcrf(
  method = "smcrf-single-param",
  statistics_target = NULL,
  statistics_selection = NULL,
  smcrf_results = NULL,
  model,
  rprior,
  dprior,
  perturbation = "Gaussian",
  perturbation_parameters = NULL,
  nParticles,
  model_redo_if_NA = FALSE,
  parallel = FALSE,
  save_model = TRUE,
  save_rds = FALSE,
  filename_rds = "ABCSMCDRF.rds",
  ...
)
}
\arguments{
\item{method}{Random forest method to implement in each iteration (\code{"smcrf-single-param"} by default).
method = \code{"smcrf-single-param"}: implements ABC-RF for each parameter and results in their marginal posterior distributions.
method = \code{"smcrf-multi-param"}: implements ABC-DRF for all parameters and results in the joint posterior distribution.}

\item{statistics_target}{A dataframe containing statistics from data.
Column names are the statistics IDs.
\code{\link{smcrf}} only supports one row of statistics.
If there are multiple observations, we recommend applying \code{\link{smcrf}} to each row individually.}

\item{statistics_selection}{A dataframe indicating selection of statistics for fitting individual parameters (only works for method \code{"smcrf-single-param"}; \code{NULL} by default).
Each column's name matches one statistic ID, and each row's name matches one parameter ID.
The value is 1 if the statistic is used for the parameter, 0 otherwise.}

\item{smcrf_results}{An existing ABC-SMC-RF result.
If provided, smcrf will continue ABC-SMC-RF from the last iteration of the previous run.}

\item{model}{Model for the statistics.
The function must take two inputs: a dataframe \code{parameters} and logic variable \code{parallel}.
The model must output a reference table, where each row contains parameters for each simulation and corresponding statistics.
The column names of the reference table must match the parameter and statistics IDs.}

\item{rprior}{Function to generate particles from the prior distribution.
The function must take one input: \code{Nparameters}, the number of particles to generate.
The output is a dataframe where column names match parameter IDs,
and each row contains one parameter set.}

\item{dprior}{Function to compute the prior density.
The function must take two inputs: \code{parameters} and \code{parameter_id}.
The dataframe \code{parameters} contains parameter sets in each row, with column names as parameter IDs.
The \code{parameter_id} is either \code{"all"} or one of the parameter IDs.
The output is a vector of prior probabilities corresponding to rows in \code{parameters},
either for the parameter indicated by \code{parameter_id} or jointly for all parameters (if \code{parameter_id} = \code{"all"}).}

\item{perturbation}{Perturbation method for the parameters.
\code{\link{smcrf}} supports \code{perturbation} = \code{"Gaussian"} (default) or \code{"Uniform"}.}

\item{perturbation_parameters}{A dataframe containing the parameters for the perturbation.
Each row corresponds to one iteration, and each column corresponds to one parameter (the column 
names must match parameter_ids).
The values are the normal distribution variances (for \code{perturbation} = \code{"Gaussian"}) or ranges (for \code{perturbation} = \code{"Uniform"}).}

\item{nParticles}{A vector of particle counts.
Each entry indicates the number of simulations (e.g. particles) in the corresponding iteration.}

\item{model_redo_if_NA}{A logic variable (\code{FALSE} by default).
If \code{model_redo_if_NA} = \code{TRUE}, the particles where \code{model} returns \code{NA} will be simulated again.}

\item{parallel}{A logic variable (\code{FALSE} by default).
If \code{parallel} = \code{TRUE}, the ABC-RF functions will be computed in parallel.}

\item{save_model}{A logic variable (\code{FALSE} by default).
If \code{save_model} = \code{TRUE}, the random forest will be saved in \code{\link{smcrf}}'s output.}

\item{save_rds}{A logic variable (\code{FALSE} by default).
If \code{save_rds} = \code{TRUE}, the ABC-SMC-RF results will be saved in an rds file.}

\item{filename_rds}{A string (\code{"ABCSMCDRF.rds"} by default).
If \code{save_rds} = \code{TRUE}, the output from ABC-SMC-(D)RF will be saved in a file with this name.}

\item{...}{Additional arguments to be passed to \code{abcrf} or \code{drf}.}
}
\value{
An object \code{smcrf_results} containing the results of the inference.
If the posterior distributions have not converged to a satisfactory level,
the user may continue with \code{smcrf(smcrf_results = smcrf_results, ...)},
in which case ABC-SMC-(D)RF will continue iterating from the last run in \code{smcrf_results}.
}
\description{
\code{\link{smcrf}} uses random forests to find the posterior distribution(s) for one or more parameters in a model.
It implements the sequential Monte Carlo framework, where each iteration
uses either ABC-RF (functions \code{regAbcrf} and \code{predict} in R package \code{abcrf})
or ABC-DRF (functions \code{drf} and \code{predict} in R package \code{drf}) to update the posterior distribution(s).
}
\examples{
library(abcsmcrf)
#--------------------------------------------------------------------
#---------------------------ABC-SMC-RF for a model with one parameter
#--------------------------------------------------------------------
#    Data to be fitted consists of two statistics s1 and s2
statistics_target <- data.frame(s1 = 0, s2 = 2)
#    We define a parametrized model for the statistics
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$theta - 1 + runif(nrow(parameters), -0.1, 0.1),
        s2 = parameters$theta + 1 + runif(nrow(parameters), -0.1, 0.1)
    )
    cbind(parameters, statistics)
}
#    and the perturbation parameters for a uniform perturbation
perturbation_parameters <- data.frame(
     theta = rep(0.1, 2) # vector length is equal to number of ABC-SMC-(D)RF iterations
)
#    We then define rprior and dprior
rprior <- function(Nparameters){
     theta <- runif(Nparameters, -10, 10)
     return(data.frame(theta = theta))
}
dprior <- function(parameters, parameter_id = "theta"){
     return(rep(1/20, nrow(parameters)))
}
#    Finally, we run ABC-SMC-RF with 2 iterations, each with 1000 particles
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    statistics_target = statistics_target,
    model = model,
    rprior = rprior, 
    dprior = dprior,
    perturbation = "Uniform",
    perturbation_parameters = perturbation_parameters,
    nParticles = c(1000, 1000),
)
#    Now we examine the posterior distribution of theta
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_theta <- smcrf_results[[posterior_iteration]]$parameters$theta
#    We look at the posterior mean of theta
theta_mean <- mean(posterior_theta)
print(theta_mean)
#    Notice that the mean is close to 1, the true value of theta.
#    We can also look at the posterior variance of theta
theta_var <- var(posterior_theta)
print(theta_var)
#    We can also continue the ABC-SMC-RF run if the posterior convergence is not satisfactory
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    smcrf_results = smcrf_results,
    model = model,
    rprior = rprior, 
    dprior = dprior,
    perturbation = "Uniform",
    perturbation_parameters = perturbation_parameters,
    nParticles = c(1000, 1000),
)
#    We can look again at the posterior mean and variance of theta
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_theta <- smcrf_results[[posterior_iteration]]$parameters$theta
theta_mean <- mean(posterior_theta)
print(theta_mean)
theta_var <- var(posterior_theta)
print(theta_var)
#    and notice whether there is any improvement in the posterior distribution
#    We can continue the runs of ABC-SMC-(D)RF similarly for the examples below
#--------------------------------------------------------------------
#---------------------ABC-SMC-RF for a model with multiple parameters
#--------------------------------------------------------------------
#    Data to be fitted consists of two statistics s1 and s2
statistics_target <- data.frame(s1 = 4, s2 = 4)
#    We then define a parametrized model for the statistics
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$mu + parameters$theta + runif(nrow(parameters), -0.1, 0.1),
        s2 = parameters$mu * parameters$theta + runif(nrow(parameters), -0.1, 0.1)
    )
    cbind(parameters, statistics)
}
#    and the perturbation parameters
perturbation_parameters <- data.frame(
     theta = rep(0.1, 3),
     mu = rep(0.1, 3)
)
#    We define the rprior and dprior functions
rprior <- function(Nparameters){
     theta <- runif(Nparameters, -10, 10)
     mu <- runif(Nparameters, -10, 10)
     return(data.frame(theta = theta, mu = mu))
}
dprior <- function(parameters, parameter_id = "all"){
     probs <- rep(1, nrow(parameters))
     if (parameter_id \%in\% c("all", "theta")){
         probs <- probs * dunif(parameters[["theta"]], -10, 10)
     }
     if (parameter_id \%in\% c("all", "mu")){
         probs <- probs * dunif(parameters[["mu"]], -10, 10)
     }
     return(probs)
}
#    Finally, we run ABC-SMC-RF with 3 iterations, each with 1000 particles
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    statistics_target = statistics_target,
    model = model,
    rprior = rprior, 
    dprior = dprior,
    perturbation = "Uniform",
    perturbation_parameters = perturbation_parameters,
    nParticles = c(1000, 1000, 1000),
)
#    Now we examine the posterior distribution of each parameter
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_params <- smcrf_results[[posterior_iteration]]$parameters
posterior_means <- colMeans(posterior_params)
posterior_vars <- var(posterior_params)
print(posterior_means)
print(posterior_vars)
#--------------------------------------------------------------------
#--------------------------------ABC-SMC-DRF for a multivariate model
#--------------------------------------------------------------------
#    Data to be fitted consists of two statistics s1 and s2
statistics_target <- data.frame(s1 = 9, s2 = 18)
#    We then define a parametrized model for the statistics
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$mu + parameters$theta + runif(nrow(parameters), -0.1, 0.1),
        s2 = parameters$mu * parameters$theta + runif(nrow(parameters), -0.1, 0.1)
    )
    cbind(parameters, statistics)
}
#    and the perturbation parameters
perturbation_parameters <- data.frame(
     theta = rep(0.1, 3),
     mu = rep(0.1, 3)
)
#    We define the rprior and dprior functions
rprior <- function(Nparameters){
     theta <- runif(Nparameters, -10, 10)
     mu <- runif(Nparameters, -10, 10)
     return(data.frame(theta = theta, mu = mu))
}
dprior <- function(parameters, parameter_id = "all"){
     probs <- rep(1, nrow(parameters))
     if (parameter_id \%in\% c("all", "theta")){
         probs <- probs * dunif(parameters[["theta"]], -10, 10)
     }
     if (parameter_id \%in\% c("all", "mu")){
         probs <- probs * dunif(parameters[["mu"]], -10, 10)
     }
     return(probs)
}
#    Finally, we run ABC-SMC-DRF with 3 iterations, each with 1000 particles
smcrf_results <- smcrf(
    method = "smcrf-multi-param",
    statistics_target = statistics_target,
    model = model,
    rprior = rprior, 
    dprior = dprior,
    perturbation = "Uniform",
    perturbation_parameters = perturbation_parameters,
    nParticles = c(1000, 1000, 1000),
)
#    Now we examine the posterior distribution of each parameter
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_params <- smcrf_results[[posterior_iteration]]$parameters
posterior_means <- colMeans(posterior_params)
posterior_vars <- var(posterior_params)
print(posterior_means)
print(posterior_vars)
}
